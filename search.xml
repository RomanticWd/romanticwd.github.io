<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java内存模型和并发编程-知识图谱</title>
    <url>/2023/02/13/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/</url>
    <content><![CDATA[<p>Java内存模型和并发编程相关知识梳理，如：JMM、线程八锁、死锁、synchronized、volatile、aqs等。</p>
<span id="more"></span>

<p><img src="/images/jmm-parallel.png" alt="Java内存模型和并发编程-知识图谱"></p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>知识图谱</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据?</title>
    <url>/2023/02/06/MySQL-%E9%87%8C%E6%9C%89-2000w-%E6%95%B0%E6%8D%AE%EF%BC%8CRedis-%E4%B8%AD%E5%8F%AA%E5%AD%98-20w-%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81-Redis-%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E9%83%BD%E6%98%AF%E7%83%AD%E7%82%B9%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<p>Redis存储在内存中的数据升到配置大小时，就进行数据淘汰</p>
<p>使用 allkeys-lru 策略，从数据集（server.db[i].dict）中挑选最近最少使用的数据优先淘汰，即可满足保存热点数据</p>
<span id="more"></span>

<h2 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h2><p>Redis 提供 6 种数据淘汰策略：</p>
<ol>
<li><strong>volatile-lru（least recently used）</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li>
<li><strong>volatile-ttl</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li>
<li><strong>volatile-random</strong>：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li>
<li><strong>allkeys-lru（least recently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）</li>
<li><strong>allkeys-random</strong>：从数据集（server.db[i].dict）中任意选择数据淘汰</li>
<li><strong>no-eviction</strong>：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！</li>
</ol>
<p>4.0 版本后增加以下两种：</p>
<ol>
<li><strong>volatile-lfu（least frequently used）</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选最不经常使用的数据淘汰</li>
<li><strong>allkeys-lfu（least frequently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key</li>
</ol>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>垃圾回收和内存分配-知识图谱</title>
    <url>/2023/02/06/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D-%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/</url>
    <content><![CDATA[<p>垃圾回收相关知识梳理，如：垃圾回收算法、垃圾回收器、虚拟机的内存区域和分配、jdk调优参数。</p>
<span id="more"></span>

<p><img src="/images/gabage-collection.png" alt="垃圾回收和内存分配-知识图谱"></p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>知识图谱</tag>
      </tags>
  </entry>
  <entry>
    <title>欧几里得算法和裴蜀定理</title>
    <url>/2023/02/15/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95%E5%92%8C%E8%A3%B4%E8%9C%80%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<p>欧几里德算法（又称辗转相除法）和裴蜀定理在算法中的应用。</p>
<span id="more"></span>

<h1 id="欧几里德算法"><a href="#欧几里德算法" class="headerlink" title="欧几里德算法"></a>欧几里德算法</h1><p>欧几里德算法，又称辗转相除法。</p>
<blockquote>
<p>假设有非零正整数 A、B，其中 A &gt; B，将 A 减 B 记为 C，即 A - B &#x3D; C。<br>最大公约数记为 GCD（greatest common divisor），例如 A、B 的最大公约数记为 GCD(A, B)。<br>求证：GCD(A, B) &#x3D; GCD(B, R),（其中 R 为 A 除以 B 的余数，或记为 R &#x3D; A - n * B，n 为 A 除以 B 的商。即 R &#x3D; A % B）</p>
</blockquote>
<h3 id="第一步：证明-GCD-A-B-能够整除-C"><a href="#第一步：证明-GCD-A-B-能够整除-C" class="headerlink" title="第一步：证明 GCD(A, B) 能够整除 C"></a>第一步：证明 GCD(A, B) 能够整除 C</h3><p>1.因为 GCD(A, B) 是 A 的公约数，存在整数 X，使得 X * GCD(A, B) &#x3D; A；</p>
<p>2.因为 GCD(A, B) 是 B 的公约数，存在整数 Y，使得 Y * GCD(A, B) &#x3D; B；</p>
<p>3.因为 A - B &#x3D; C，即</p>
<p>X * GCD(A, B) - Y * GCD(A, B) &#x3D; C</p>
<p>(X - Y) * GCD(A, B) &#x3D; C</p>
<p>使用图片表示即：<br><img src="https://img-blog.csdn.net/20180506172836174"></p>
<p>所以有结论：</p>
<h5 id="GCD-A-B-不仅是-A-和-B-的最大公约数，同时也是-C-的约数。"><a href="#GCD-A-B-不仅是-A-和-B-的最大公约数，同时也是-C-的约数。" class="headerlink" title="GCD(A, B) 不仅是 A 和 B 的最大公约数，同时也是 C 的约数。"></a>GCD(A, B) 不仅是 A 和 B 的最大公约数，同时也是 C 的约数。</h5><h3 id="第二步：证明-GCD-B-C-能够整除-A"><a href="#第二步：证明-GCD-B-C-能够整除-A" class="headerlink" title="第二步：证明 GCD(B, C) 能够整除 A"></a>第二步：证明 GCD(B, C) 能够整除 A</h3><p>1.因为 GCD(B, C) 是 B 的公约数，存在整数 M，使得 M * GCD(B, C) &#x3D; B；</p>
<p>2.因为 GCD(B, C) 是 C 的公约数，存在整数 N，使得 N * GCD(B, C) &#x3D; C；</p>
<p>3.因为 B + C &#x3D; A，即</p>
<p>M * GCD(B, C) + N * GCD(B, C) &#x3D; A</p>
<p>(M + N) * GCD(B, C) &#x3D; A</p>
<p>使用图片表示即：<br><img src="https://img-blog.csdn.net/20180506172851787"></p>
<p>所以有结论：</p>
<h5 id="GCD-B-C-不仅是-B-和-C-的最大公约数，同时也是-A-的约数。"><a href="#GCD-B-C-不仅是-B-和-C-的最大公约数，同时也是-A-的约数。" class="headerlink" title="GCD(B, C) 不仅是 B 和 C 的最大公约数，同时也是 A 的约数。"></a>GCD(B, C) 不仅是 B 和 C 的最大公约数，同时也是 A 的约数。</h5><h3 id="第三步：证明-GCD-A-B-x3D-GCD-B-C"><a href="#第三步：证明-GCD-A-B-x3D-GCD-B-C" class="headerlink" title="第三步：证明 GCD(A, B) &#x3D; GCD(B, C)"></a>第三步：证明 GCD(A, B) &#x3D; GCD(B, C)</h3><p>1.因为 GCD(A, B) 是 A 和 B 的最大公约数，同时也是 C 的约数，所以 GCD(A, B) 一定也是 B 和 C 的约数。由于 GCD(B, C) 是 B 和 C 的最大公约数，所以存在</p>
<p>GCD(A, B) &lt;&#x3D; GCD(B, C)</p>
<p>2.因为 GCD(B, C) 是 B 和 C 的最大公约数，同时也是 A 的约数，所以 GCD(B, C) 一定也是 A 和 B 的约数。由于 GCD(A, B) 是 A 和 B 的最大公约数，所以存在</p>
<p>GCD(B, C) &lt;&#x3D; GCD(A, B)</p>
<p>3.由上可得 GCD(A, B) &#x3D; GCD(B, C)</p>
<p>使用图片表示即：<br><img src="https://img-blog.csdn.net/20180506172915683"></p>
<h3 id="第四步：证明-GCD-A-B-x3D-GCD-B-R"><a href="#第四步：证明-GCD-A-B-x3D-GCD-B-R" class="headerlink" title="第四步：证明 GCD(A, B) &#x3D; GCD(B, R)"></a>第四步：证明 GCD(A, B) &#x3D; GCD(B, R)</h3><p>1.因为 GCD(A, B) &#x3D; GCD(B, C)，即 GCD(A, B) &#x3D; GCD(B, A - B)</p>
<p>2.上式也可记为 GCD(A, B) &#x3D; GCD(A - B, B)</p>
<p>3.重复上一步，即有</p>
<p>GCD(A, B) &#x3D; GCD(A - B, B) &#x3D; GCD(A - 2B, B) &#x3D; … &#x3D; GCD(A - n * B, B)</p>
<p>4.所以 GCD(A, B) &#x3D; GCD(B, R)</p>
<h2 id="欧几里得算法扩展，求最大公约数的算法"><a href="#欧几里得算法扩展，求最大公约数的算法" class="headerlink" title="欧几里得算法扩展，求最大公约数的算法"></a>欧几里得算法扩展，求最大公约数的算法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static int gcd(int a, int b) &#123;</span><br><span class="line">    if (a &lt; 0 || b &lt; 0) &#123;</span><br><span class="line">        return -1; // 数学上不考虑负数的约数</span><br><span class="line">    &#125;</span><br><span class="line">    if (b == 0) &#123;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line">    // 可以整除的时候才是约数，此时b的值就是最大公约数</span><br><span class="line">    while (a % b != 0) &#123;</span><br><span class="line">        // 不停的取余</span><br><span class="line">        int temp = a % b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    return b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="裴蜀定理"><a href="#裴蜀定理" class="headerlink" title="裴蜀定理"></a>裴蜀定理</h2><p>对于不全为零的任意整数 a 和 b，记 g&#x3D;gcd⁡(a,b)，其中 gcd⁡(a,b) 为 a 和 b 的最小公约数，则对于任意整数 x 和 y 都满足 a<em>x+b</em>y是 g 的倍数，特别地，存在整数 x 和 y 满足 a<em>x+b</em>y&#x3D;g。</p>
<p>「裴蜀定理」也可以推广到多个整数的情况。对于不全为零的任意 n个整数 a1,a2,…an<br> ，记这 n个数的最大公约数为 g，则对于任意 n 个整数 x1,x2,…xn都满足 ∑i&#x3D;ai<em>xi<br>  是 g 的倍数。一个重要的推论是：正整数 a1到 an 的最大公约数是 1 的充分必要条件是存在 n 个整数 x1到 xn满足 ∑i&#x3D;ai</em>xi&#x3D;1.</p>
<h3 id="裴蜀定理扩展"><a href="#裴蜀定理扩展" class="headerlink" title="裴蜀定理扩展"></a>裴蜀定理扩展</h3><p><a href="https://leetcode.cn/problems/check-if-it-is-a-good-array/description/">1250. 检查「好数组</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public boolean isGoodArray(int[] nums) &#123;</span><br><span class="line">        int divisor = nums[0];</span><br><span class="line">        for (int num : nums) &#123;</span><br><span class="line">            divisor = gcd(divisor, num);</span><br><span class="line">            if (divisor == 1) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return divisor == 1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
